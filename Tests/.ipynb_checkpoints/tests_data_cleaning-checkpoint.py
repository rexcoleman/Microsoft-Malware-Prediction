import pandas as pd
import numpy as np
import dask.dataframe as dd
from sklearn import preprocessing
import warnings, sys
if not sys.warnoptions:
    warnings.simplefilter("ignore")


def test_rename_Census_ActivationChannel(df):
    # Expected unique values after renaming
    unique_values_before = {'oem', 'volume', 'retail'}
    
    # Unique values before renaming (not relevant here but useful for debugging)
    # unique_values_before = df['Census_ActivationChannel'].unique()
    # print("Unique values before renaming:")
    print(unique_values_before)
    
    # Unique values after renaming
    unique_values_after = set(df['Census_ActivationChannel'].unique())
    print("\nUnique values after renaming:")
    print(unique_values_after)
    
    # Assert that the unique values after renaming match the expected values
    assert unique_values_after.issubset(unique_values_before), f"Unexpected values found: {unique_values_after - unique_values_before}"
    
    # Print sample rows to manually check renaming
    print("\nSample rows after renaming:")
    print(df[['Census_ActivationChannel']].sample(5))
    
    # Assert statements to check specific sample values
    sample_values = df['Census_ActivationChannel'].sample(100).tolist()
    for value in sample_values:
        assert value in unique_values_before, f"Unexpected value: {value}"
    
    # Count occurrences after renaming
    count_after = df['Census_ActivationChannel'].value_counts()
    print("\nCount of occurrences after renaming:")
    print(count_after)
    
    # Assert that the sum of counts matches the length of the DataFrame (ensuring no data loss)
    assert count_after.sum() == len(df), "Mismatch in the total number of entries after renaming"
    
    # Assert that each category count is non-zero (ensuring all categories are represented)
    for category in unique_values_after:
        assert category in count_after.index, f"Category '{category}' not found in the renamed values"
        assert count_after[category] > 0, f"Category '{category}' has zero occurrences"
    
    # Print final confirmation that all tests passed
    print("All tests passed!")


def test_rename_Census_ChassisTypeName(df):
    # Expected unique values after renaming
    unique_values_before = {'31', 'busexpansionchassis', '36', 'subnotebook', '44', 'lunchbox', '81', 'bladeenclosure', 'subchassis', '30', '39', 'expansionchassis', 'spacesaving', '0', 'multisystemchassis', 'convertible', 'mainserverchassis', '49', '88', 'lowprofiledesktop', 'pizzabox', '76', '112', 'compactpci', 'iotgateway', 'desktop', '28', 'sealedcasepc', '35', '45', 'minipc', 'minitower', '127', 'portable', 'stickpc', 'tower', '32', 'notebook', 'dockingstation', 'blade', 'unknown', '82', '25', 'rackmountchassis', 'tablet', 'detachable', 'handheld', 'embeddedpc', 'allinone'}
    
    # Unique values before renaming
    # unique_values_before = df['Census_ChassisTypeName'].unique()
    # print("Unique values before renaming:")
    print(unique_values_before)
    
    # Unique values after renaming
    unique_values_after = set(df['Census_ChassisTypeName'].unique())
    print("\nUnique values after renaming:")
    print(unique_values_after)
    
    # Assert that the unique values after renaming match the expected values
    assert unique_values_after.issubset(unique_values_before), f"Unexpected values found: {unique_values_after - unique_values_before}"
    
    # Print sample rows to manually check renaming
    print("\nSample rows after renaming:")
    print(df[['Census_ChassisTypeName']].sample(5))
    
    # Assert statements to check specific sample values
    sample_values = df['Census_ChassisTypeName'].sample(100).tolist()
    for value in sample_values:
        assert value in unique_values_before, f"Unexpected value: {value}"
    
    # Count occurrences after renaming
    count_after = df['Census_ChassisTypeName'].value_counts()
    print("\nCount of occurrences after renaming:")
    print(count_after)
    
    # Assert that the sum of counts matches the length of the DataFrame (ensuring no data loss)
    assert count_after.sum() == len(df), "Mismatch in the total number of entries after renaming"
    
    # Assert that each category count is non-zero (ensuring all categories are represented)
    for category in unique_values_after:
        assert category in count_after.index, f"Category '{category}' not found in the renamed values"
        assert count_after[category] > 0, f"Category '{category}' has zero occurrences"


def test_Census_DeviceFamily(df):
    # Expected unique values after renaming
    unique_values_before = {'windows.desktop', 'windows.server'}

    # Unique values before renaming
    # unique_values_before = df['Census_DeviceFamily'].unique()
    # print("Unique values before renaming:")
    print(unique_values_before)

    # Apply the renaming function
    df['Census_DeviceFamily'].replace(['windows'], 'windows.desktop', inplace=True)
    df['Census_DeviceFamily'] = df['Census_DeviceFamily'].astype('category')
    df['Census_DeviceFamily'] = df['Census_DeviceFamily'].cat.remove_unused_categories()

    # Unique values after renaming
    unique_values_after = set(df['Census_DeviceFamily'].unique())
    print("\nUnique values after renaming:")
    print(unique_values_after)

    # Assert that the unique values after renaming match the expected values
    assert unique_values_after.issubset(unique_values_before), f"Unexpected values found: {unique_values_after - unique_values_before}"

    # Print sample rows to manually check renaming
    print("\nSample rows after renaming:")
    print(df[['Census_DeviceFamily']].sample(5))

    # Assert statements to check specific sample values
    sample_values = df['Census_DeviceFamily'].sample(100).tolist()
    for value in sample_values:
        assert value in unique_values_before, f"Unexpected value: {value}"

    # Count occurrences after renaming
    count_after = df['Census_DeviceFamily'].value_counts()
    print("\nCount of occurrences after renaming:")
    print(count_after)

    # Assert that the sum of counts matches the length of the DataFrame (ensuring no data loss)
    assert count_after.sum() == len(df), "Mismatch in the total number of entries after renaming"

    # Assert that each category count is non-zero (ensuring all categories are represented)
    for category in unique_values_after:
        assert category in count_after.index, f"Category '{category}' not found in the renamed values"
        assert count_after[category] > 0, f"Category '{category}' has zero occurrences"

    print("All tests passed!")


def test_Census_FlightRing(df):
    # Expected unique values after renaming
    unique_values_before = {'not_set', 'unknown', 'rp', 'retail', 'wif', 'wis'}

    # Unique values before renaming
    # unique_values_before = df['Census_FlightRing'].unique()
    # print("Unique values before renaming:")
    print(unique_values_before)

    # Unique values after renaming
    unique_values_after = set(df['Census_FlightRing'].unique())
    print("\nUnique values after renaming:")
    print(unique_values_after)

    # Assert that the unique values after renaming match the expected values
    assert unique_values_after.issubset(unique_values_before), f"Unexpected values found: {unique_values_after - unique_values_before}"

    # Print sample rows to manually check renaming
    print("\nSample rows after renaming:")
    print(df[['Census_FlightRing']].sample(5))

    # Assert statements to check specific sample values
    sample_values = df['Census_FlightRing'].sample(100).tolist()
    for value in sample_values:
        assert value in unique_values_before, f"Unexpected value: {value}"

    # Count occurrences after renaming
    count_after = df['Census_FlightRing'].value_counts()
    print("\nCount of occurrences after renaming:")
    print(count_after)

    # Assert that the sum of counts matches the length of the DataFrame (ensuring no data loss)
    assert count_after.sum() == len(df), "Mismatch in the total number of entries after renaming"

    # Assert that each category count is non-zero (ensuring all categories are represented)
    for category in unique_values_after:
        assert category in count_after.index, f"Category '{category}' not found in the renamed values"
        assert count_after[category] > 0, f"Category '{category}' has zero occurrences"

    print("All tests passed!")


def test_Census_GenuineStateName(df):
    # Expected unique values after renaming
    unique_values_before = {'unknown', 'genuine', 'offline', 'invalid', 'isnotgenuine', 'isgenuinetampered'}

    # Unique values before renaming
    # unique_values_before = df['Census_GenuineStateName'].unique()
    # print("Unique values before renaming:")
    print(unique_values_before)

    # Unique values after renaming
    unique_values_after = set(df['Census_GenuineStateName'].unique())
    print("\nUnique values after renaming:")
    print(unique_values_after)

    # Assert that the unique values after renaming match the expected values
    assert unique_values_after.issubset(unique_values_before), f"Unexpected values found: {unique_values_after - unique_values_before}"

    # Print sample rows to manually check renaming
    print("\nSample rows after renaming:")
    print(df[['Census_GenuineStateName']].sample(5))

    # Assert statements to check specific sample values
    sample_values = df['Census_GenuineStateName'].sample(100).tolist()
    for value in sample_values:
        assert value in unique_values_before, f"Unexpected value: {value}"

    # Count occurrences after renaming
    count_after = df['Census_GenuineStateName'].value_counts()
    print("\nCount of occurrences after renaming:")
    print(count_after)

    # Assert that the sum of counts matches the length of the DataFrame (ensuring no data loss)
    assert count_after.sum() == len(df), "Mismatch in the total number of entries after renaming"

    # Assert that each category count is non-zero (ensuring all categories are represented)
    for category in unique_values_after:
        assert category in count_after.index, f"Category '{category}' not found in the renamed values"
        assert count_after[category] > 0, f"Category '{category}' has zero occurrences"

    print("All tests passed!")


def test_Census_MDC2FormFactor_new(df):
    # Expected unique values after renaming
    unique_values_before = {'server', 'tablet', 'allinone', 'convertible', 'detachable', 'desktop', 'embeddedpc', 'handheld', 'laptop', 'notebook', 'smartdisplay', 'stickpc', 'tower', 'pcother', 'iotother'}

    # Unique values before renaming
    # unique_values_before = df['Census_MDC2FormFactor_new'].unique()
    # print("Unique values before renaming:")
    print(unique_values_before)

    # Unique values after renaming
    unique_values_after = set(df['Census_MDC2FormFactor_new'].unique())
    print("\nUnique values after renaming:")
    print(unique_values_after)

    # Assert that the unique values after renaming match the expected values
    assert unique_values_after.issubset(unique_values_before), f"Unexpected values found: {unique_values_after - unique_values_before}"

    # Print sample rows to manually check renaming
    print("\nSample rows after renaming:")
    print(df[['Census_MDC2FormFactor_new']].sample(5))

    # Assert statements to check specific sample values
    sample_values = df['Census_MDC2FormFactor_new'].sample(100).tolist()
    for value in sample_values:
        assert value in unique_values_before, f"Unexpected value: {value}"

    # Count occurrences after renaming
    count_after = df['Census_MDC2FormFactor_new'].value_counts()
    print("\nCount of occurrences after renaming:")
    print(count_after)

    # Assert that the sum of counts matches the length of the DataFrame (ensuring no data loss)
    assert count_after.sum() == len(df), "Mismatch in the total number of entries after renaming"

    # Assert that each category count is non-zero (ensuring all categories are represented)
    for category in unique_values_after:
        assert category in count_after.index, f"Category '{category}' not found in the renamed values"
        assert count_after[category] > 0, f"Category '{category}' has zero occurrences"

    print("All tests passed!")


def test_Census_OSEdition(df):
    # Expected unique values after renaming
    unique_values_before = {'core', 'pro', 'enterprise', 'server', 'home', 'education', 'cloud', 'unknown'}

    # Unique values before renaming
    unique_values_before = df['Census_OSEdition'].unique()
    print("Unique values before renaming:")
    print(unique_values_before)

    # Unique values after renaming
    unique_values_after = set(df['Census_OSEdition'].unique())
    print("\nUnique values after renaming:")
    print(unique_values_after)

    # Assert that the unique values after renaming match the expected values
    assert unique_values_after.issubset(unique_values_before), f"Unexpected values found: {unique_values_after - unique_values_before}"

    # Print sample rows to manually check renaming
    print("\nSample rows after renaming:")
    print(df[['Census_OSEdition']].sample(5))

    # Assert statements to check specific sample values
    sample_values = df['Census_OSEdition'].sample(100).tolist()
    for value in sample_values:
        assert value in unique_values_before, f"Unexpected value: {value}"

    # Count occurrences after renaming
    count_after = df['Census_OSEdition'].value_counts()
    print("\nCount of occurrences after renaming:")
    print(count_after)

    # Assert that the sum of counts matches the length of the DataFrame (ensuring no data loss)
    assert count_after.sum() == len(df), "Mismatch in the total number of entries after renaming"

    # Assert that each category count is non-zero (ensuring all categories are represented)
    for category in unique_values_after:
        assert category in count_after.index, f"Category '{category}' not found in the renamed values"
        assert count_after[category] > 0, f"Category '{category}' has zero occurrences"

    print("All tests passed!")


def test_Census_OSSkuName(df):
    # Expected unique values after renaming
    unique_values_before = {'core', 'pro', 'enterprise', 'server', 'home', 'education', 'cloud'}

    # Unique values before renaming
    unique_values_before = df['Census_OSSkuName'].unique()
    print("Unique values before renaming:")
    print(unique_values_before)

    # Unique values after renaming
    unique_values_after = set(df['Census_OSSkuName'].unique())
    print("\nUnique values after renaming:")
    print(unique_values_after)

    # Assert that the unique values after renaming match the expected values
    assert unique_values_after.issubset(unique_values_before), f"Unexpected values found: {unique_values_after - unique_values_before}"

    # Print sample rows to manually check renaming
    print("\nSample rows after renaming:")
    print(df[['Census_OSSkuName']].sample(5))

    # Assert statements to check specific sample values
    sample_values = df['Census_OSSkuName'].sample(100).tolist()
    for value in sample_values:
        assert value in unique_values_before, f"Unexpected value: {value}"

    # Count occurrences after renaming
    count_after = df['Census_OSSkuName'].value_counts()
    print("\nCount of occurrences after renaming:")
    print(count_after)

    # Assert that the sum of counts matches the length of the DataFrame (ensuring no data loss)
    assert count_after.sum() == len(df), "Mismatch in the total number of entries after renaming"

    # Assert that each category count is non-zero (ensuring all categories are represented)
    for category in unique_values_after:
        assert category in count_after.index, f"Category '{category}' not found in the renamed values"
        assert count_after[category] > 0, f"Category '{category}' has zero occurrences"

    print("All tests passed!")


def test_Census_PowerPlatformRoleName(df):
    # Expected unique values after renaming
    unique_values_before = {'unknown', 'appliance', 'console', 'desktop', 'enterprise server', 'mobile', 'performance server', 'slate', 'workstation'}

    # Unique values before renaming
    unique_values_before = df['Census_PowerPlatformRoleName'].unique()
    print("Unique values before renaming:")
    print(unique_values_before)

    # Unique values after renaming
    unique_values_after = set(df['Census_PowerPlatformRoleName'].unique())
    print("\nUnique values after renaming:")
    print(unique_values_after)

    # Assert that the unique values after renaming match the expected values
    assert unique_values_after.issubset(unique_values_before), f"Unexpected values found: {unique_values_after - unique_values_before}"

    # Print sample rows to manually check renaming
    print("\nSample rows after renaming:")
    print(df[['Census_PowerPlatformRoleName']].sample(5))

    # Assert statements to check specific sample values
    sample_values = df['Census_PowerPlatformRoleName'].sample(100).tolist()
    for value in sample_values:
        assert value in unique_values_before, f"Unexpected value: {value}"

    # Count occurrences after renaming
    count_after = df['Census_PowerPlatformRoleName'].value_counts()
    print("\nCount of occurrences after renaming:")
    print(count_after)

    # Assert that the sum of counts matches the length of the DataFrame (ensuring no data loss)
    assert count_after.sum() == len(df), "Mismatch in the total number of entries after renaming"

    # Assert that each category count is non-zero (ensuring all categories are represented)
    for category in unique_values_after:
        assert category in count_after.index, f"Category '{category}' not found in the renamed values"
        assert count_after[category] > 0, f"Category '{category}' has zero occurrences"

    print("All tests passed!")


def test_Census_PrimaryDiskTypeName(df):
    # Expected unique values after renaming
    unique_values_before = {'unknown', 'hdd', 'ssd', 'emmc', 'flash', 'removable'}

    # Unique values before renaming
    unique_values_before = df['Census_PrimaryDiskTypeName'].unique()
    print("Unique values before renaming:")
    print(unique_values_before)

    # Unique values after renaming
    unique_values_after = set(df['Census_PrimaryDiskTypeName'].unique())
    print("\nUnique values after renaming:")
    print(unique_values_after)

    # Assert that the unique values after renaming match the expected values
    assert unique_values_after.issubset(unique_values_before), f"Unexpected values found: {unique_values_after - unique_values_before}"

    # Print sample rows to manually check renaming
    print("\nSample rows after renaming:")
    print(df[['Census_PrimaryDiskTypeName']].sample(5))

    # Assert statements to check specific sample values
    sample_values = df['Census_PrimaryDiskTypeName'].sample(100).tolist()
    for value in sample_values:
        assert value in unique_values_before, f"Unexpected value: {value}"

    # Count occurrences after renaming
    count_after = df['Census_PrimaryDiskTypeName'].value_counts()
    print("\nCount of occurrences after renaming:")
    print(count_after)

    # Assert that the sum of counts matches the length of the DataFrame (ensuring no data loss)
    assert count_after.sum() == len(df), "Mismatch in the total number of entries after renaming"

    # Assert that each category count is non-zero (ensuring all categories are represented)
    for category in unique_values_after:
        assert category in count_after.index, f"Category '{category}' not found in the renamed values"
        assert count_after[category] > 0, f"Category '{category}' has zero occurrences"

    print("All tests passed!")


def test_OsBuildLab(df):
    # Expected unique values after renaming
    unique_values_before = set(df['OsBuildLab'].cat.categories)

    # Unique values before renaming
    unique_values_before = df['OsBuildLab'].unique()
    print("Unique values before renaming:")
    print(unique_values_before)

    # Unique values after renaming
    unique_values_after = set(df['OsBuildLab'].unique())
    print("\nUnique values after renaming:")
    print(unique_values_after)

    # Assert that 'unknown' is added to the categories
    assert 'unknown' in unique_values_before, f"'unknown' not found in categories: {unique_values_before}"

    # Assert that the unique values after renaming match the expected values
    assert unique_values_after.issubset(unique_values_before), f"Unexpected values found: {unique_values_after - unique_values_before}"

    # Print sample rows to manually check renaming
    print("\nSample rows after renaming:")
    print(df[['OsBuildLab']].sample(5))

    # Assert statements to check specific sample values
    sample_values = df['OsBuildLab'].sample(100).tolist()
    for value in sample_values:
        assert value in unique_values_before, f"Unexpected value: {value}"

    # Count occurrences after renaming
    count_after = df['OsBuildLab'].value_counts()
    print("\nCount of occurrences after renaming:")
    print(count_after)

    # Assert that the sum of counts matches the length of the DataFrame (ensuring no data loss)
    assert count_after.sum() == len(df), "Mismatch in the total number of entries after renaming"

    # Assert that each category count is non-zero (ensuring all categories are represented)
    for category in unique_values_after:
        assert category in count_after.index, f"Category '{category}' not found in the renamed values"
        assert count_after[category] > 0, f"Category '{category}' has zero occurrences"

    print("All tests passed!")




