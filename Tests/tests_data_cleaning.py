import pandas as pd
import numpy as np
import dask.dataframe as dd
from sklearn import preprocessing
from tqdm import tqdm  
import warnings, sys
if not sys.warnoptions:
    warnings.simplefilter("ignore")


def aggregate_clean_tests(df):
    test_rename_Census_ActivationChannel(df)
    test_rename_Census_ChassisTypeName(df)
    test_Census_DeviceFamily(df)
    test_Census_FlightRing(df)
    test_Census_GenuineStateName(df)
    test_Census_MDC2FormFactor_new(df)
    test_Census_OSEdition(df)
    test_Census_OSSkuName(df)
    test_Census_PowerPlatformRoleName(df)
    test_Census_PrimaryDiskTypeName(df)
    test_OsBuildLab(df)
    test_SmartScreen(df)
    test_replace_AvSigVersion(df)
    

def test_replace_AvSigVersion(df):
    # Value to be replaced
    original_value = '1.2&#x17;3.1144.0'
    # Replacement value
    replacement_value = '1.2173.1144.0'
    
    # Apply the replacement
    df['AvSigVersion'].replace([original_value], replacement_value, inplace=True)
    
    # Check that the original value is not present in the DataFrame
    assert original_value not in df['AvSigVersion'].values, f"Original value '{original_value}' still found in DataFrame"
    
    # Print confirmation
    print(f"All tests passed: '{original_value}' has been replaced with '{replacement_value}' in the 'AvSigVersion' column!")


def test_rename_Census_ActivationChannel(df):
    # Expected unique values after renaming
    unique_values_before = {'oem', 'volume', 'retail'}
    
    # Unique values before renaming (not relevant here but useful for debugging)
    # unique_values_before = df['Census_ActivationChannel'].unique()
    # print("Unique values before renaming:")
    print(unique_values_before)
    
    # Unique values after renaming
    unique_values_after = set(df['Census_ActivationChannel'].unique())
    print("\nUnique values after renaming:")
    print(unique_values_after)
    
    # Assert that the unique values after renaming match the expected values
    assert unique_values_after.issubset(unique_values_before), f"Unexpected values found: {unique_values_after - unique_values_before}"
    
    # Print sample rows to manually check renaming
    print("\nSample rows after renaming:")
    print(df[['Census_ActivationChannel']].sample(5))
    
    # Assert statements to check specific sample values
    sample_values = df['Census_ActivationChannel'].sample(100).tolist()
    for value in sample_values:
        assert value in unique_values_before, f"Unexpected value: {value}"
    
    # Count occurrences after renaming
    count_after = df['Census_ActivationChannel'].value_counts()
    print("\nCount of occurrences after renaming:")
    print(count_after)
    
    # Assert that the sum of counts matches the length of the DataFrame (ensuring no data loss)
    assert count_after.sum() == len(df), "Mismatch in the total number of entries after renaming"
    
    # Assert that each category count is non-zero (ensuring all categories are represented)
    for category in unique_values_after:
        assert category in count_after.index, f"Category '{category}' not found in the renamed values"
        assert count_after[category] > 0, f"Category '{category}' has zero occurrences"
    
    # Print final confirmation that all tests passed
    print("All tests passed!")


def test_rename_Census_ChassisTypeName(df):
    # Expected unique values after renaming
    unique_values_before = {'31', 'busexpansionchassis', '36', 'subnotebook', '44', 'lunchbox', '81', 'bladeenclosure', 'subchassis', '30', '39', 'expansionchassis', 'spacesaving', '0', 'multisystemchassis', 'convertible', 'mainserverchassis', '49', '88', 'lowprofiledesktop', 'pizzabox', '76', '112', 'compactpci', 'iotgateway', 'desktop', '28', 'sealedcasepc', '35', '45', 'minipc', 'minitower', '127', 'portable', 'stickpc', 'tower', '32', 'notebook', 'dockingstation', 'blade', 'unknown', '82', '25', 'rackmountchassis', 'tablet', 'detachable', 'handheld', 'embeddedpc', 'allinone', '120', '64', 'peripheralchassis', 'Notebook', '93', '83'}
    
    # Unique values before renaming
    # unique_values_before = df['Census_ChassisTypeName'].unique()
    # print("Unique values before renaming:")
    print(unique_values_before)
    
    # Unique values after renaming
    unique_values_after = set(df['Census_ChassisTypeName'].unique())
    print("\nUnique values after renaming:")
    print(unique_values_after)
    
    # Assert that the unique values after renaming match the expected values
    assert unique_values_after.issubset(unique_values_before), f"Unexpected values found: {unique_values_after - unique_values_before}"
    
    # Print sample rows to manually check renaming
    print("\nSample rows after renaming:")
    print(df[['Census_ChassisTypeName']].sample(5))
    
    # Assert statements to check specific sample values
    sample_values = df['Census_ChassisTypeName'].sample(100).tolist()
    for value in sample_values:
        assert value in unique_values_before, f"Unexpected value: {value}"
    
    # Count occurrences after renaming
    count_after = df['Census_ChassisTypeName'].value_counts()
    print("\nCount of occurrences after renaming:")
    print(count_after)
    
    # Assert that the sum of counts matches the length of the DataFrame (ensuring no data loss)
    assert count_after.sum() == len(df), "Mismatch in the total number of entries after renaming"
    
    # Assert that each category count is non-zero (ensuring all categories are represented)
    for category in unique_values_after:
        assert category in count_after.index, f"Category '{category}' not found in the renamed values"
        assert count_after[category] > 0, f"Category '{category}' has zero occurrences"


def test_Census_DeviceFamily(df):
    # Expected unique values after renaming
    unique_values_before = {'windows.desktop', 'windows.server'}

    # Unique values before renaming
    # unique_values_before = df['Census_DeviceFamily'].unique()
    # print("Unique values before renaming:")
    print(unique_values_before)

    # Apply the renaming function
    df['Census_DeviceFamily'].replace(['windows'], 'windows.desktop', inplace=True)
    df['Census_DeviceFamily'] = df['Census_DeviceFamily'].astype('category')
    df['Census_DeviceFamily'] = df['Census_DeviceFamily'].cat.remove_unused_categories()

    # Unique values after renaming
    unique_values_after = set(df['Census_DeviceFamily'].unique())
    print("\nUnique values after renaming:")
    print(unique_values_after)

    # Assert that the unique values after renaming match the expected values
    assert unique_values_after.issubset(unique_values_before), f"Unexpected values found: {unique_values_after - unique_values_before}"

    # Print sample rows to manually check renaming
    print("\nSample rows after renaming:")
    print(df[['Census_DeviceFamily']].sample(5))

    # Assert statements to check specific sample values
    sample_values = df['Census_DeviceFamily'].sample(100).tolist()
    for value in sample_values:
        assert value in unique_values_before, f"Unexpected value: {value}"

    # Count occurrences after renaming
    count_after = df['Census_DeviceFamily'].value_counts()
    print("\nCount of occurrences after renaming:")
    print(count_after)

    # Assert that the sum of counts matches the length of the DataFrame (ensuring no data loss)
    assert count_after.sum() == len(df), "Mismatch in the total number of entries after renaming"

    # Assert that each category count is non-zero (ensuring all categories are represented)
    for category in unique_values_after:
        assert category in count_after.index, f"Category '{category}' not found in the renamed values"
        assert count_after[category] > 0, f"Category '{category}' has zero occurrences"

    print("All tests passed!")


def test_Census_FlightRing(df):
    # Expected unique values after renaming
    unique_values_before = {'not_set', 'unknown', 'rp', 'retail', 'wif', 'wis', 'cbcanary'}

    # Unique values before renaming
    # unique_values_before = df['Census_FlightRing'].unique()
    # print("Unique values before renaming:")
    print(unique_values_before)

    # Unique values after renaming
    unique_values_after = set(df['Census_FlightRing'].unique())
    print("\nUnique values after renaming:")
    print(unique_values_after)

    # Assert that the unique values after renaming match the expected values
    assert unique_values_after.issubset(unique_values_before), f"Unexpected values found: {unique_values_after - unique_values_before}"

    # Print sample rows to manually check renaming
    print("\nSample rows after renaming:")
    print(df[['Census_FlightRing']].sample(5))

    # Assert statements to check specific sample values
    sample_values = df['Census_FlightRing'].sample(100).tolist()
    for value in sample_values:
        assert value in unique_values_before, f"Unexpected value: {value}"

    # Count occurrences after renaming
    count_after = df['Census_FlightRing'].value_counts()
    print("\nCount of occurrences after renaming:")
    print(count_after)

    # Assert that the sum of counts matches the length of the DataFrame (ensuring no data loss)
    assert count_after.sum() == len(df), "Mismatch in the total number of entries after renaming"

    # Assert that each category count is non-zero (ensuring all categories are represented)
    for category in unique_values_after:
        assert category in count_after.index, f"Category '{category}' not found in the renamed values"
        assert count_after[category] > 0, f"Category '{category}' has zero occurrences"

    print("All tests passed!")


def test_Census_GenuineStateName(df):
    # Expected unique values after renaming
    unique_values_before = {'unknown', 'genuine', 'offline', 'invalid', 'isnotgenuine', 'isgenuinetampered'}

    # Unique values before renaming
    # unique_values_before = df['Census_GenuineStateName'].unique()
    # print("Unique values before renaming:")
    print(unique_values_before)

    # Unique values after renaming
    unique_values_after = set(df['Census_GenuineStateName'].unique())
    print("\nUnique values after renaming:")
    print(unique_values_after)

    # Assert that the unique values after renaming match the expected values
    assert unique_values_after.issubset(unique_values_before), f"Unexpected values found: {unique_values_after - unique_values_before}"

    # Print sample rows to manually check renaming
    print("\nSample rows after renaming:")
    print(df[['Census_GenuineStateName']].sample(5))

    # Assert statements to check specific sample values
    sample_values = df['Census_GenuineStateName'].sample(100).tolist()
    for value in sample_values:
        assert value in unique_values_before, f"Unexpected value: {value}"

    # Count occurrences after renaming
    count_after = df['Census_GenuineStateName'].value_counts()
    print("\nCount of occurrences after renaming:")
    print(count_after)

    # Assert that the sum of counts matches the length of the DataFrame (ensuring no data loss)
    assert count_after.sum() == len(df), "Mismatch in the total number of entries after renaming"

    # Assert that each category count is non-zero (ensuring all categories are represented)
    for category in unique_values_after:
        assert category in count_after.index, f"Category '{category}' not found in the renamed values"
        assert count_after[category] > 0, f"Category '{category}' has zero occurrences"

    print("All tests passed!")


def test_Census_MDC2FormFactor_new(df):
    # Expected unique values after renaming
    unique_values_before = {'server', 'tablet', 'allinone', 'convertible', 'detachable', 'desktop', 'embeddedpc', 'handheld', 'laptop', 'notebook', 'smartdisplay', 'stickpc', 'tower', 'pcother', 'iotother', 'other'}

    # Unique values before renaming
    # unique_values_before = df['Census_MDC2FormFactor_new'].unique()
    # print("Unique values before renaming:")
    print(unique_values_before)

    # Unique values after renaming
    unique_values_after = set(df['Census_MDC2FormFactor_new'].unique())
    print("\nUnique values after renaming:")
    print(unique_values_after)

    # Assert that the unique values after renaming match the expected values
    assert unique_values_after.issubset(unique_values_before), f"Unexpected values found: {unique_values_after - unique_values_before}"

    # Print sample rows to manually check renaming
    print("\nSample rows after renaming:")
    print(df[['Census_MDC2FormFactor_new']].sample(5))

    # Assert statements to check specific sample values
    sample_values = df['Census_MDC2FormFactor_new'].sample(100).tolist()
    for value in sample_values:
        assert value in unique_values_before, f"Unexpected value: {value}"

    # Count occurrences after renaming
    count_after = df['Census_MDC2FormFactor_new'].value_counts()
    print("\nCount of occurrences after renaming:")
    print(count_after)

    # Assert that the sum of counts matches the length of the DataFrame (ensuring no data loss)
    assert count_after.sum() == len(df), "Mismatch in the total number of entries after renaming"

    # Assert that each category count is non-zero (ensuring all categories are represented)
    for category in unique_values_after:
        assert category in count_after.index, f"Category '{category}' not found in the renamed values"
        assert count_after[category] > 0, f"Category '{category}' has zero occurrences"

    print("All tests passed!")


def test_Census_OSEdition(df):
    # Expected unique values after renaming
    unique_values_before = {'core', 'pro', 'enterprise', 'server', 'home', 'education', 'cloud', 'unknown'}

    # Unique values before renaming
    unique_values_before = df['Census_OSEdition'].unique()
    print("Unique values before renaming:")
    print(unique_values_before)

    # Unique values after renaming
    unique_values_after = set(df['Census_OSEdition'].unique())
    print("\nUnique values after renaming:")
    print(unique_values_after)

    # Assert that the unique values after renaming match the expected values
    assert unique_values_after.issubset(unique_values_before), f"Unexpected values found: {unique_values_after - unique_values_before}"

    # Print sample rows to manually check renaming
    print("\nSample rows after renaming:")
    print(df[['Census_OSEdition']].sample(5))

    # Assert statements to check specific sample values
    sample_values = df['Census_OSEdition'].sample(100).tolist()
    for value in sample_values:
        assert value in unique_values_before, f"Unexpected value: {value}"

    # Count occurrences after renaming
    count_after = df['Census_OSEdition'].value_counts()
    print("\nCount of occurrences after renaming:")
    print(count_after)

    # Assert that the sum of counts matches the length of the DataFrame (ensuring no data loss)
    assert count_after.sum() == len(df), "Mismatch in the total number of entries after renaming"

    # Assert that each category count is non-zero (ensuring all categories are represented)
    for category in unique_values_after:
        assert category in count_after.index, f"Category '{category}' not found in the renamed values"
        assert count_after[category] > 0, f"Category '{category}' has zero occurrences"

    print("All tests passed!")


def test_Census_OSSkuName(df):
    # Expected unique values after renaming
    unique_values_before = {'core', 'pro', 'enterprise', 'server', 'home', 'education', 'cloud'}

    # Unique values before renaming
    unique_values_before = df['Census_OSSkuName'].unique()
    print("Unique values before renaming:")
    print(unique_values_before)

    # Unique values after renaming
    unique_values_after = set(df['Census_OSSkuName'].unique())
    print("\nUnique values after renaming:")
    print(unique_values_after)

    # Assert that the unique values after renaming match the expected values
    assert unique_values_after.issubset(unique_values_before), f"Unexpected values found: {unique_values_after - unique_values_before}"

    # Print sample rows to manually check renaming
    print("\nSample rows after renaming:")
    print(df[['Census_OSSkuName']].sample(5))

    # Assert statements to check specific sample values
    sample_values = df['Census_OSSkuName'].sample(100).tolist()
    for value in sample_values:
        assert value in unique_values_before, f"Unexpected value: {value}"

    # Count occurrences after renaming
    count_after = df['Census_OSSkuName'].value_counts()
    print("\nCount of occurrences after renaming:")
    print(count_after)

    # Assert that the sum of counts matches the length of the DataFrame (ensuring no data loss)
    assert count_after.sum() == len(df), "Mismatch in the total number of entries after renaming"

    # Assert that each category count is non-zero (ensuring all categories are represented)
    for category in unique_values_after:
        assert category in count_after.index, f"Category '{category}' not found in the renamed values"
        assert count_after[category] > 0, f"Category '{category}' has zero occurrences"

    print("All tests passed!")


def test_Census_PowerPlatformRoleName(df):
    # Expected unique values after renaming
    unique_values_before = {'unknown', 'appliance', 'console', 'desktop', 'enterprise server', 'mobile', 'performance server', 'slate', 'workstation'}

    # Unique values before renaming
    unique_values_before = df['Census_PowerPlatformRoleName'].unique()
    print("Unique values before renaming:")
    print(unique_values_before)

    # Unique values after renaming
    unique_values_after = set(df['Census_PowerPlatformRoleName'].unique())
    print("\nUnique values after renaming:")
    print(unique_values_after)

    # Assert that the unique values after renaming match the expected values
    assert unique_values_after.issubset(unique_values_before), f"Unexpected values found: {unique_values_after - unique_values_before}"

    # Print sample rows to manually check renaming
    print("\nSample rows after renaming:")
    print(df[['Census_PowerPlatformRoleName']].sample(5))

    # Assert statements to check specific sample values
    sample_values = df['Census_PowerPlatformRoleName'].sample(100).tolist()
    for value in sample_values:
        assert value in unique_values_before, f"Unexpected value: {value}"

    # Count occurrences after renaming
    count_after = df['Census_PowerPlatformRoleName'].value_counts()
    print("\nCount of occurrences after renaming:")
    print(count_after)

    # Assert that the sum of counts matches the length of the DataFrame (ensuring no data loss)
    assert count_after.sum() == len(df), "Mismatch in the total number of entries after renaming"

    # Assert that each category count is non-zero (ensuring all categories are represented)
    for category in unique_values_after:
        assert category in count_after.index, f"Category '{category}' not found in the renamed values"
        assert count_after[category] > 0, f"Category '{category}' has zero occurrences"

    print("All tests passed!")


def test_Census_PrimaryDiskTypeName(df):
    # Expected unique values after renaming
    unique_values_before = {'unknown', 'hdd', 'ssd', 'emmc', 'flash', 'removable'}

    # Unique values before renaming
    unique_values_before = df['Census_PrimaryDiskTypeName'].unique()
    print("Unique values before renaming:")
    print(unique_values_before)

    # Unique values after renaming
    unique_values_after = set(df['Census_PrimaryDiskTypeName'].unique())
    print("\nUnique values after renaming:")
    print(unique_values_after)

    # Assert that the unique values after renaming match the expected values
    assert unique_values_after.issubset(unique_values_before), f"Unexpected values found: {unique_values_after - unique_values_before}"

    # Print sample rows to manually check renaming
    print("\nSample rows after renaming:")
    print(df[['Census_PrimaryDiskTypeName']].sample(5))

    # Assert statements to check specific sample values
    sample_values = df['Census_PrimaryDiskTypeName'].sample(100).tolist()
    for value in sample_values:
        assert value in unique_values_before, f"Unexpected value: {value}"

    # Count occurrences after renaming
    count_after = df['Census_PrimaryDiskTypeName'].value_counts()
    print("\nCount of occurrences after renaming:")
    print(count_after)

    # Assert that the sum of counts matches the length of the DataFrame (ensuring no data loss)
    assert count_after.sum() == len(df), "Mismatch in the total number of entries after renaming"

    # Assert that each category count is non-zero (ensuring all categories are represented)
    for category in unique_values_after:
        assert category in count_after.index, f"Category '{category}' not found in the renamed values"
        assert count_after[category] > 0, f"Category '{category}' has zero occurrences"

    print("All tests passed!")


def test_OsBuildLab(df):
    # Expected unique values after renaming
    unique_values_before = set(df['OsBuildLab'].cat.categories)

    # Unique values before renaming
    unique_values_before = df['OsBuildLab'].unique()
    print("Unique values before renaming:")
    print(unique_values_before)

    # Unique values after renaming
    unique_values_after = set(df['OsBuildLab'].unique())
    print("\nUnique values after renaming:")
    print(unique_values_after)

    # Assert that 'unknown' is added to the categories
    assert 'unknown' in unique_values_before, f"'unknown' not found in categories: {unique_values_before}"

    # Assert that the unique values after renaming match the expected values
    assert unique_values_after.issubset(unique_values_before), f"Unexpected values found: {unique_values_after - unique_values_before}"

    # Print sample rows to manually check renaming
    print("\nSample rows after renaming:")
    print(df[['OsBuildLab']].sample(5))

    # Assert statements to check specific sample values
    sample_values = df['OsBuildLab'].sample(100).tolist()
    for value in sample_values:
        assert value in unique_values_before, f"Unexpected value: {value}"

    # Count occurrences after renaming
    count_after = df['OsBuildLab'].value_counts()
    print("\nCount of occurrences after renaming:")
    print(count_after)

    # Assert that the sum of counts matches the length of the DataFrame (ensuring no data loss)
    assert count_after.sum() == len(df), "Mismatch in the total number of entries after renaming"

    # Assert that each category count is non-zero (ensuring all categories are represented)
    for category in unique_values_after:
        assert category in count_after.index, f"Category '{category}' not found in the renamed values"
        assert count_after[category] > 0, f"Category '{category}' has zero occurrences"

    print("All tests passed!")


def test_SmartScreen(df):
    # Expected unique values after renaming
    unique_values_before = {'prompt', 'requireadmin', 'existsnotset', 'off', 'warn', 'block', 'on', 'unknown'}

    # Unique values before renaming
    unique_values_before = df['SmartScreen'].unique()
    print("Unique values before renaming:")
    print(unique_values_before)

    # Unique values after renaming
    unique_values_after = set(df['SmartScreen'].unique())
    print("\nUnique values after renaming:")
    print(unique_values_after)

    # Assert that 'unknown' is added to the categories
    assert 'unknown' in unique_values_before, f"'unknown' not found in categories: {unique_values_before}"

    # Assert that the unique values after renaming match the expected values
    assert unique_values_after.issubset(unique_values_before), f"Unexpected values found: {unique_values_after - unique_values_before}"

    # Print sample rows to manually check renaming
    print("\nSample rows after renaming:")
    print(df[['SmartScreen']].sample(5))

    # Assert statements to check specific sample values
    sample_values = df['SmartScreen'].sample(100).tolist()
    for value in sample_values:
        assert value in unique_values_before, f"Unexpected value: {value}"

    # Count occurrences after renaming
    count_after = df['SmartScreen'].value_counts()
    print("\nCount of occurrences after renaming:")
    print(count_after)

    # Assert that the sum of counts matches the length of the DataFrame (ensuring no data loss)
    assert count_after.sum() == len(df), "Mismatch in the total number of entries after renaming"

    # Assert that each category count is non-zero (ensuring all categories are represented)
    for category in unique_values_after:
        assert category in count_after.index, f"Category '{category}' not found in the renamed values"
        assert count_after[category] > 0, f"Category '{category}' has zero occurrences"

    print("All tests passed!")


import pandas as pd

def test_no_missing_values(df):
    # Calculate total and percentage of missing values
    total = df.isnull().sum().sort_values(ascending=False)
    percent = (df.isnull().sum() / df.isnull().count() * 100).sort_values(ascending=False)
    missing_train_data = pd.concat([total, percent], axis=1, keys=['Total', 'Percent'])
    
    # Print missing data for debugging
    print("\nMissing data:")
    print(missing_train_data)
    
    # Assert there are no missing values
    assert missing_train_data['Total'].sum() == 0, f"There are missing values in the DataFrame"
    
    print("All tests passed: No missing values in the DataFrame!")

# Example usage:
# test_no_missing_values(df)


def test_no_missing_values_in_test_data(test_df, target_feature='HasDetections'):
    # Calculate total and percentage of missing values
    total = test_df.isnull().sum().sort_values(ascending=False)
    percent = (test_df.isnull().sum() / test_df.isnull().count() * 100).sort_values(ascending=False)
    missing_test_data = pd.concat([total, percent], axis=1, keys=['Total', 'Percent'])
    
    # Print missing data for debugging
    print("\nMissing data in test DataFrame:")
    print(missing_test_data)
    
    # Assert there are no missing values in columns other than the target feature
    non_target_missing = missing_test_data.drop(index=target_feature)
    assert non_target_missing['Total'].sum() == 0, f"There are missing values in the test DataFrame (excluding {target_feature})"
    
    print("All tests passed: No missing values in the test DataFrame (excluding the target feature)!")
    
    # Print special case handling for the target feature
    target_missing = missing_test_data.loc[target_feature]
    print(f"\nSpecial case handling for target feature '{target_feature}':")
    print(target_missing)

# Example usage:
# test_no_missing_values_in_test_data(test_df)





